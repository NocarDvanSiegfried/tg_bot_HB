# Устранение дублирования сообщений "Панель управления" - Единая функция рендеринга

## Проблема

Меню "Панель управления" создавалось из нескольких мест:
- Команда `/panel`
- Callback `panel_main`
- Дублирование текста в разных местах

В результате бот отправлял ДВА разных сообщения с панелью.

## Решение

Создана единая функция `render_panel_menu()`, которая:
- Принимает `bot`, `chat_id`, `user_id`, опционально `existing_message_id`
- Сама решает: редактировать существующее сообщение или отправить новое
- Использует единый текст из `_get_panel_menu_text()`
- Никогда не создает дубликаты

## Архитектурное решение

### 1. Единая функция получения текста

```python
def _get_panel_menu_text() -> str:
    """
    Получает единый текст меню панели управления.
    
    КРИТИЧНО: Это единственное место, где определяется текст панели.
    Все обработчики должны использовать этот текст.
    """
```

### 2. Единая функция рендеринга

```python
async def render_panel_menu(
    bot: Bot,
    chat_id: int,
    user_id: int,
    existing_message_id: Optional[int] = None
) -> int:
    """
    Рендерит меню панели управления.
    
    КРИТИЧНО: Это единственная функция, которая создает/редактирует панель управления.
    - Если есть existing_message_id или сохраненный message_id - редактирует существующее сообщение
    - Если нет - отправляет новое сообщение
    - Никогда не создает дубликаты
    """
```

**Логика работы:**
1. Получает единый текст через `_get_panel_menu_text()`
2. Определяет `message_id` для редактирования:
   - Если передан `existing_message_id` → использует его
   - Иначе → берет из хранилища `_panel_menu_messages`
3. Если `message_id` найден:
   - Пытается отредактировать существующее сообщение
   - При успехе → сохраняет `message_id` и возвращает его
   - При ошибке → удаляет из хранилища и отправляет новое
4. Если `message_id` не найден:
   - Отправляет новое сообщение
   - Сохраняет `message_id` в хранилище

### 3. Использование в обработчиках

**Команда `/panel`:**
```python
@router.message(Command("panel"))
async def cmd_panel(message: Message, bot: Bot, session: AsyncSession):
    # ... запись доступа ...
    
    # КРИТИЧНО: Используем единую функцию рендеринга панели
    await render_panel_menu(
        bot=bot,
        chat_id=message.chat.id,
        user_id=user_id,
    )
```

**Callback `panel_main`:**
```python
@router.callback_query(lambda c: c.data == "panel_main")
async def panel_main_callback(callback: CallbackQuery, bot: Bot):
    # КРИТИЧНО: Используем единую функцию рендеринга панели
    # Передаем existing_message_id для гарантии редактирования текущего сообщения
    await render_panel_menu(
        bot=bot,
        chat_id=callback.message.chat.id,
        user_id=user_id,
        existing_message_id=message_id,
    )
```

## Изменения

### Файл: `backend/src/presentation/telegram/handlers/panel_handler.py`

#### 1. Добавлена функция `_get_panel_menu_text()`
- Единственное место определения текста панели
- Учитывает наличие Mini App URL

#### 2. Добавлена функция `render_panel_menu()`
- Единственная функция создания/редактирования панели
- Автоматически решает: редактировать или отправить новое
- Обрабатывает ошибки редактирования

#### 3. Изменена функция `cmd_panel()`
- Удален дублированный текст
- Использует только `render_panel_menu()`

#### 4. Изменена функция `panel_main_callback()`
- Удален дублированный текст
- Использует только `render_panel_menu()`
- Передает `existing_message_id` для гарантии редактирования

## Поведение

### ✅ Сценарий 1: Первый вызов `/panel`
- `render_panel_menu()` не находит `message_id` в хранилище
- Отправляет новое сообщение
- Сохраняет `message_id` в хранилище

### ✅ Сценарий 2: Повторный вызов `/panel`
- `render_panel_menu()` находит `message_id` в хранилище
- Редактирует существующее сообщение
- Новое сообщение не создается

### ✅ Сценарий 3: Возврат в меню через `panel_main`
- `render_panel_menu()` получает `existing_message_id` из callback
- Редактирует существующее сообщение
- Обновляет `message_id` в хранилище
- Новое сообщение не создается

### ✅ Сценарий 4: Сообщение удалено пользователем
- При следующем вызове редактирование не удастся
- Ошибка обрабатывается, старое `message_id` удаляется
- Отправляется новое сообщение

## Логирование

Добавлено подробное логирование:

```
[Panel] Отредактировано существующее сообщение с меню для пользователя 123456 (chat_id=789, message_id=123)
[Panel] Отправлено новое сообщение с меню для пользователя 123456 (chat_id=789, message_id=124)
[Panel] Не удалось отредактировать сообщение 123 для пользователя 123456: MessageNotModified. Отправляется новое сообщение.
```

## Гарантии

✅ **Панель управления существует РОВНО В ОДНОМ сообщении на пользователя**

✅ **Любой вход в панель редактирует существующее сообщение или отправляет новое (если нет)**

✅ **send_message допускается ТОЛЬКО если сообщения панели нет или его невозможно отредактировать**

✅ **Текст панели управления ЕДИНЫЙ (одна версия текста)**

✅ **ОДНА функция рендера панели: `render_panel_menu()`**

✅ **Запрещено:**
- Дублировать текст панели
- Создавать панель напрямую из callback'ов
- Иметь разные версии меню

## Ограничения

✅ **Соблюдено:**
- НЕ изменён frontend
- НЕ изменён Mini App
- НЕ изменён cache-busting
- НЕ изменён start_param
- НЕ изменён nginx
- Изменения только на уровне логики Telegram-бота

## Критерий готовности

✅ **Достигнуто:**
- При любом количестве вызовов `/panel` и кликов:
  - В чате всегда ОДНО сообщение панели
  - Никаких "выскакивающих" дубликатов
  - Единый текст панели
  - Единая функция рендеринга

**Решение готово к использованию.**

