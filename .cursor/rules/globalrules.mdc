---
alwaysApply: true
---

# Code Quality & Structure
- Remove all duplicate code: repeated functions, imports, components, or logic.
- Eliminate cyclic dependencies across modules.
- Avoid hardcoded values; all constants must be in ENV, config, or design tokens.
- Use only existing, valid modules and dependencies from the project.
- Do not create new entities, files, or modules unless required by established architecture.
- Maintain the "one file â€” one responsibility" principle.
- Delete leftover, unused, or temporary code after completing tasks.

# Consistency & Clean Architecture
- Follow the monorepo folder structure exactly.
- Adhere strictly to architectural documentation and existing project patterns.
- Apply deterministic, maintainable solutions with clear boundaries (domain, infra, UI, etc.).
- Use established naming conventions from the project.
- Avoid side-effects, global states, and implicit behavior unless defined in architecture.

# Code Writing Standards
- All imports must be placed at the top of the file, grouped and ordered consistently.
- Avoid early returns at the very beginning of functions; the main return should appear at the logical end unless early return improves clarity without breaking structure.
- Code must remain server-compatible; avoid browser globals unless required explicitly.
- All algorithms should follow well-established common patterns unless there is a clear justification for deviation.
- Code must remain clean:
    - no dead code
    - no unused imports or variables
    - no hardcoded values (use config/constants/tokens)
    - no duplicate logic or structures
    - no magic numbers or strings inline
- Do not use forbidden or non-existent APIs, libraries, or modules.
- Only rely on standard or project-approved libraries.
- Each file must follow the Single Responsibility Principle.
- Naming must be consistent, descriptive, and aligned with project conventions.
- Complex logic must be broken into small, reusable, pure functions.
- Avoid deeply nested structures; simplify control flow when possible.
- Comments must describe intent, not restate code.

# Frontend Checks
- Ensure the frontend can run:
    npm run dev
- Ensure production builds pass without errors:
    npm run build

# Backend Checks
- Ensure backend builds successfully:
    docker compose build
- Ensure backend services start without warnings or runtime errors:
    docker compose up

# MCP Automation Rules
When the user submits ANY request:
    Call the tool "context7.load" (or the correct method name) with no arguments.
    Incorporate its output into the reasoning before generating an answer.
When the request involves comparing interfaces, checking site behavior,
verifying a live UI, or exploring external pages:
    Call the tool "playwright.run" with the given URL or page context.


When the request involves UI, DOM, layout, animation, visual behavior,
rendering issues, or frontend component logic:
    Call the tool "playwright.run" with the current project state.
    Use the output to adjust the reasoning.

# Constraints
- Do not call tools that do not exist in the MCP configuration.
- Do not define new tool methods or fake modules.
- Never infer project structure incorrectly; verify before referencing paths.
- Do not produce code that violates build or runtime constraints of the project.


# Reliability & Testing
- Ensure that changes do not break existing tests or automation.
- Prefer writing idempotent, deterministic transformations.

# Security & Safety (minimal, only practical)
- Avoid introducing insecure patterns (e.g., eval, global exposure).

# TDD Workflow Rules
- Before implementing any new function or modifying existing logic, 
  always generate the corresponding test file or test cases first.
- After writing the tests, implement the function in the simplest correct form.
- After implementation, automatically run the tests using the project's test runner (npm test / pytest / go test/ docker test).
- If tests fail, refine the implementation until the tests pass.
- Do not skip tests or generate incomplete/mocked tests without necessity.
- Ensure all tests follow clear, deterministic, and maintainable patterns.
- Test files must follow the same architecture and naming conventions as the project.
- No code is considered "done" until its tests fully pass.

When the user requests an implementation, modification, or new feature:
    1. Generate the appropriate test file or test cases first.
    2. Wait for approval or proceed automatically if no conflict exists.
    3. Implement the function according to the tests.
    4. Run the test suite.
    5. If any tests fail, fix the implementation until the test suite passes.