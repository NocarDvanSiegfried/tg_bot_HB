---
alwaysApply: true
---

# Deployment Environment Preparedness Rules

## General Principles
- The project must be architected assuming that real deployment environments 
  (domains, DNS, SSL, proxies, bot platforms) are often misconfigured.
- Code and configuration must tolerate these issues gracefully.
- The system must expose clear diagnostics when environment problems occur.

---

## Domain & DNS Awareness
- No hardcoded domain names in code; all domains must come from environment variables.
- All features that rely on a domain must provide:
    - documentation of required DNS records (A, CNAME, etc.)
    - a sanity check to verify that the domain resolves correctly
- The application must not assume DNS propagation is instantaneous.

---

## SSL / Certificate Awareness
- All public-facing routes must assume HTTPS by default.
- No feature may rely on self-signed certificates unless explicitly in development mode.
- The project must provide a clear mechanism to verify:
    - certificate presence
    - certificate validity
    - correct domain binding
- Code must handle SSL handshake errors gracefully.

---

## Reverse Proxy / Routing Awareness
- The application must not assume it runs directly on the root domain.
- All routing must support:
    - reverse proxies
    - subpaths (e.g., example.com/app/)
    - forwarded headers (X-Forwarded-For, X-Forwarded-Proto)
- No absolute URLs unless they are composed from environment variables.

---

## Port & Binding Safety
- Services must explicitly define their listening ports in config.
- Code must not assume that port 80/443/3000/8000 are available.
- Health-check endpoints must be available on configurable paths.

---

## Telegram & Webhook Preparedness
- Bot/webhook integrations must assume that:
    - the domain may not be reachable initially
    - SSL might not be ready during deployment
    - webhook registration may fail several times
- The system must:
    - validate webhook URL format before registration
    - verify URL reachability
    - retry registration with backoff

---

## External Connectivity Checks
- Before enabling features that depend on external services, the system must:
    - test raw network connectivity (DNS + TCP)
    - verify correct protocol (HTTP/HTTPS)
    - validate that required ports are open
- The project must not assume that the deployment server has unrestricted outbound internet access.

---

## CORS & Origin Safety
- All frontend/backend interactions must define:
    - allowed origins via configuration
    - secure defaults (no wildcard in production)
- The code must assume that browsers may block requests due to:
    - invalid scheme (HTTP vs HTTPS)
    - mismatched origins
    - missing CORS headers

---

## Deployment Readiness Diagnostics
The system must provide diagnostics that help identify:
    - DNS mismatch
    - certificate failure
    - incorrect webhook URL
    - unreachable API endpoint
    - wrong environment variables
    - incorrect reverse proxy configuration

Diagnostics must be:
    - explicit
    - actionable
    - human-readable

---

## Local vs Production Parity
- Local development must simulate production conditions where possible:
    - HTTPS assumptions
    - reverse proxy behavior
    - external API structure
    - webhook routes (mocked)
- The project must avoid logic that works locally but fails under a proxy or on HTTPS.
# Deployment Environment Preparedness Rules

## General Principles
- The project must be architected assuming that real deployment environments 
  (domains, DNS, SSL, proxies, bot platforms) are often misconfigured.
- Code and configuration must tolerate these issues gracefully.
- The system must expose clear diagnostics when environment problems occur.

---

## Domain & DNS Awareness
- No hardcoded domain names in code; all domains must come from environment variables.
- All features that rely on a domain must provide:
    - documentation of required DNS records (A, CNAME, etc.)
    - a sanity check to verify that the domain resolves correctly
- The application must not assume DNS propagation is instantaneous.

---

## SSL / Certificate Awareness
- All public-facing routes must assume HTTPS by default.
- No feature may rely on self-signed certificates unless explicitly in development mode.
- The project must provide a clear mechanism to verify:
    - certificate presence
    - certificate validity
    - correct domain binding
- Code must handle SSL handshake errors gracefully.

---

## Reverse Proxy / Routing Awareness
- The application must not assume it runs directly on the root domain.
- All routing must support:
    - reverse proxies
    - subpaths (e.g., example.com/app/)
    - forwarded headers (X-Forwarded-For, X-Forwarded-Proto)
- No absolute URLs unless they are composed from environment variables.

---

## Port & Binding Safety
- Services must explicitly define their listening ports in config.
- Code must not assume that port 80/443/3000/8000 are available.
- Health-check endpoints must be available on configurable paths.

---

## Telegram & Webhook Preparedness
- Bot/webhook integrations must assume that:
    - the domain may not be reachable initially
    - SSL might not be ready during deployment
    - webhook registration may fail several times
- The system must:
    - validate webhook URL format before registration
    - verify URL reachability
    - retry registration with backoff

---

## External Connectivity Checks
- Before enabling features that depend on external services, the system must:
    - test raw network connectivity (DNS + TCP)
    - verify correct protocol (HTTP/HTTPS)
    - validate that required ports are open
- The project must not assume that the deployment server has unrestricted outbound internet access.

---

## CORS & Origin Safety
- All frontend/backend interactions must define:
    - allowed origins via configuration
    - secure defaults (no wildcard in production)
- The code must assume that browsers may block requests due to:
    - invalid scheme (HTTP vs HTTPS)
    - mismatched origins
    - missing CORS headers

---

## Deployment Readiness Diagnostics
The system must provide diagnostics that help identify:
    - DNS mismatch
    - certificate failure
    - incorrect webhook URL
    - unreachable API endpoint
    - wrong environment variables
    - incorrect reverse proxy configuration

Diagnostics must be:
    - explicit
    - actionable
    - human-readable

---

## Local vs Production Parity
- Local development must simulate production conditions where possible:
    - HTTPS assumptions
    - reverse proxy behavior
    - external API structure
    - webhook routes (mocked)
- The project must avoid logic that works locally but fails under a proxy or on HTTPS.