name: Deploy

on:
  push:
    branches: [main, staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - staging
          - production

jobs:
  deploy:
    name: Deploy to ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "env=production" >> $GITHUB_OUTPUT
          else
            echo "env=staging" >> $GITHUB_OUTPUT
          fi
      
      - name: Check required secrets
        run: |
          if [ -z "${{ secrets.DEPLOY_HOST }}" ]; then
            echo "‚ùå DEPLOY_HOST secret is missing"
            exit 1
          fi
          if [ -z "${{ secrets.DEPLOY_USER }}" ]; then
            echo "‚ùå DEPLOY_USER secret is missing"
            exit 1
          fi
          if [ -z "${{ secrets.DEPLOY_PATH }}" ]; then
            echo "‚ùå DEPLOY_PATH secret is missing"
            exit 1
          fi
          if [ -z "${{ secrets.DEPLOY_SSH_KEY }}" ]; then
            echo "‚ùå DEPLOY_SSH_KEY secret is missing"
            exit 1
          fi
          # Check SSH key format
          SSH_KEY="${{ secrets.DEPLOY_SSH_KEY }}"
          if ! echo "$SSH_KEY" | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "‚ùå DEPLOY_SSH_KEY format is invalid"
            echo "   Expected format: -----BEGIN ... PRIVATE KEY-----"
            echo "   Make sure you copied the full private key including headers"
            exit 1
          fi
          echo "‚úÖ All required secrets are present and formatted correctly"
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}
      
      - name: Diagnose SSH connection
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          if [ -z "$DEPLOY_HOST" ] || [ -z "$DEPLOY_USER" ]; then
            echo "‚ùå DEPLOY_HOST or DEPLOY_USER is empty"
            exit 1
          fi
          
          echo "üîç SSH Diagnostics:"
          echo "  Host: $DEPLOY_HOST"
          echo "  User: $DEPLOY_USER"
          echo "  SSH_AUTH_SOCK: ${SSH_AUTH_SOCK:-not set}"
          
          # Check if ssh-agent is running
          if [ -z "$SSH_AUTH_SOCK" ]; then
            echo "‚ùå SSH_AUTH_SOCK is not set - ssh-agent may not be running"
            exit 1
          fi
          
          # List keys in ssh-agent
          echo "  Keys in ssh-agent:"
          ssh-add -l || echo "    ‚ö†Ô∏è  No keys found in ssh-agent"
          
          # Test SSH connection with verbose output (first attempt)
          echo ""
          echo "üîç Testing SSH connection (verbose mode)..."
          if ssh -v -o ConnectTimeout=10 -o StrictHostKeyChecking=no "$DEPLOY_USER@$DEPLOY_HOST" "echo 'SSH connection successful'" 2>&1 | head -20; then
            echo "‚úÖ SSH connection test passed"
          else
            echo ""
            echo "‚ùå SSH connection test failed"
            echo ""
            echo "üìã Troubleshooting steps:"
            echo "  1. Verify the public key is added to server:"
            echo "     On server, check: cat ~/.ssh/authorized_keys"
            echo "  2. Verify DEPLOY_USER has correct permissions:"
            echo "     On server, check: ls -la ~/.ssh/"
            echo "  3. Verify DEPLOY_SSH_KEY contains the full private key:"
            echo "     Should start with: -----BEGIN ... PRIVATE KEY-----"
            echo "  4. Verify DEPLOY_HOST is reachable:"
            echo "     Test: ping $DEPLOY_HOST"
            echo ""
            echo "‚ö†Ô∏è  Continuing with deployment, but SSH may fail..."
          fi
      
      - name: Add server to known hosts
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
        run: |
          if [ -z "$DEPLOY_HOST" ]; then
            echo "‚ùå DEPLOY_HOST is empty"
            exit 1
          fi
          ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
      
      - name: Save current images as previous
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          if [ -z "$DEPLOY_HOST" ] || [ -z "$DEPLOY_USER" ] || [ -z "$DEPLOY_PATH" ]; then
            echo "‚ùå Required deployment variables are empty"
            exit 1
          fi
          export DEPLOY_HOST DEPLOY_USER DEPLOY_PATH
          if ! ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no "$DEPLOY_USER@$DEPLOY_HOST" << EOF
            cd "$DEPLOY_PATH"
            # Tag current images as previous for rollback
            docker images --format "{{.Repository}}:{{.Tag}}" | grep -E "(backend|frontend)" | while read image; do
              if [[ ! "\$image" =~ :previous$ ]]; then
                docker tag "\$image" "\${image%:*}:previous" || true
              fi
            done
          EOF
          then
            echo "‚ùå Failed to save current images as previous"
            echo "   Check SSH connection and server permissions"
            exit 1
          fi
      
      - name: Deploy via SSH
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          ENVIRONMENT: ${{ steps.env.outputs.env }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: |
          if [ -z "$DEPLOY_HOST" ] || [ -z "$DEPLOY_USER" ] || [ -z "$DEPLOY_PATH" ]; then
            echo "‚ùå Required deployment variables are empty"
            exit 1
          fi
          export DEPLOY_HOST DEPLOY_USER DEPLOY_PATH GITHUB_REF_NAME
          if ! ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no "$DEPLOY_USER@$DEPLOY_HOST" << EOF
            cd "$DEPLOY_PATH"
            
            # Pull latest code
            git fetch origin
            git checkout "$GITHUB_REF_NAME"
            git pull origin "$GITHUB_REF_NAME"
            
            # Pull latest Docker images
            docker compose pull backend frontend
            
            # Run migrations
            docker compose exec -T backend alembic upgrade head || echo "Migration failed, continuing..."
            
            # Restart services
            docker compose up -d backend frontend
            
            # Wait for services to be ready
            sleep 10
          EOF
          then
            echo "‚ùå Deployment via SSH failed"
            echo "   Check SSH connection, server permissions, and deployment path"
            exit 1
          fi
      
      - name: Health check
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PROTOCOL: ${{ secrets.DEPLOY_PROTOCOL || 'http' }}
        run: |
          if [ -z "$DEPLOY_HOST" ]; then
            echo "‚ùå DEPLOY_HOST is empty, skipping health check"
            exit 1
          fi
          API_URL="$DEPLOY_PROTOCOL://$DEPLOY_HOST/"
          for i in {1..30}; do
            if curl -f -k "$API_URL" > /dev/null 2>&1; then
              echo "Health check passed"
              exit 0
            fi
            echo "Waiting for service to be ready... ($i/30)"
            sleep 2
          done
          echo "Health check failed"
          exit 1
      
      - name: Rollback on failure
        if: failure()
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          if [ -z "$DEPLOY_HOST" ] || [ -z "$DEPLOY_USER" ] || [ -z "$DEPLOY_PATH" ]; then
            echo "‚ùå Required deployment variables are empty, cannot rollback"
            exit 1
          fi
          export DEPLOY_HOST DEPLOY_USER DEPLOY_PATH
          if ! ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no "$DEPLOY_USER@$DEPLOY_HOST" << EOF
            cd "$DEPLOY_PATH"
            docker compose pull backend:previous frontend:previous || true
            docker compose up -d backend frontend
          EOF
          then
            echo "‚ùå Rollback via SSH failed"
            echo "   Manual intervention may be required"
            echo "   Connect to server and run:"
            echo "     cd $DEPLOY_PATH"
            echo "     docker compose pull backend:previous frontend:previous || true"
            echo "     docker compose up -d backend frontend"
            exit 1
          fi
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment successful to ${{ steps.env.outputs.env }}"
          else
            echo "‚ùå Deployment failed to ${{ steps.env.outputs.env }}"
          fi

