# Telegram Bot Configuration
TELEGRAM_BOT_TOKEN=1234567890:ABCdefGHIjklMNOpqrsTUVwxyz1234567890

# ============================================
# PostgreSQL Database Configuration
# ============================================
# ВАЖНО: Эти переменные используются в docker-compose.yml
# Убедитесь, что значения совпадают в DATABASE_URL!

# Имя пользователя PostgreSQL
# НЕ используйте это имя как имя базы данных!
POSTGRES_USER=birthday_user

# Пароль пользователя PostgreSQL
# ВАЖНО: Используйте надежный пароль в production!
# Минимум 8 символов, рекомендуется: буквы, цифры, спецсимволы
POSTGRES_PASSWORD=secure_password_2024

# Имя базы данных PostgreSQL
# ВАЖНО: Должно отличаться от POSTGRES_USER!
# PostgreSQL не создаст базу данных с именем пользователя автоматически
POSTGRES_DB=birthday_calendar_db

# ============================================
# DATABASE_URL Configuration
# ============================================
# Полный URL подключения к базе данных
# Формат: postgresql+asyncpg://USERNAME:PASSWORD@HOST:PORT/DATABASE_NAME
#
# КРИТИЧЕСКИ ВАЖНО:
# 1. DATABASE_NAME (после последнего /) ДОЛЖЕН совпадать с POSTGRES_DB
# 2. DATABASE_NAME НЕ должен совпадать с POSTGRES_USER
# 3. USERNAME должен совпадать с POSTGRES_USER
# 4. PASSWORD должен совпадать с POSTGRES_PASSWORD
# 5. Для Docker Compose используйте имя сервиса 'postgres' как HOST
# 6. Для локального запуска используйте 'localhost' как HOST
# 7. Порт обычно 5432 (стандартный порт PostgreSQL)
#
# Примеры:
#
# ✅ ПРАВИЛЬНО (для Docker Compose):
#    DATABASE_URL=postgresql+asyncpg://birthday_user:secure_password_2024@postgres:5432/birthday_calendar_db
#    где:
#    - birthday_user = POSTGRES_USER
#    - secure_password_2024 = POSTGRES_PASSWORD
#    - postgres = имя сервиса в docker-compose.yml
#    - 5432 = стандартный порт PostgreSQL
#    - birthday_calendar_db = POSTGRES_DB
#
# ✅ ПРАВИЛЬНО (для локального запуска):
#    DATABASE_URL=postgresql+asyncpg://birthday_user:secure_password_2024@localhost:5432/birthday_calendar_db
#    где localhost заменяет имя сервиса postgres
#
# ❌ НЕПРАВИЛЬНО (база данных = имя пользователя):
#    DATABASE_URL=postgresql+asyncpg://birthday_user:password@postgres:5432/birthday_user
#    Ошибка: "database 'birthday_user' does not exist"
#
# ❌ НЕПРАВИЛЬНО (несовпадение пароля):
#    POSTGRES_PASSWORD=password1
#    DATABASE_URL=postgresql+asyncpg://birthday_user:password2@postgres:5432/birthday_calendar_db
#    Ошибка: "password authentication failed"
#
# ❌ НЕПРАВИЛЬНО (несовпадение имени пользователя):
#    POSTGRES_USER=user1
#    DATABASE_URL=postgresql+asyncpg://user2:password@postgres:5432/birthday_calendar_db
#    Ошибка: "password authentication failed for user 'user2'"
#
# ❌ НЕПРАВИЛЬНО (несовпадение имени базы данных):
#    POSTGRES_DB=db1
#    DATABASE_URL=postgresql+asyncpg://user:password@postgres:5432/db2
#    Ошибка: "database 'db2' does not exist"
#
# ❌ НЕПРАВИЛЬНО (неверный хост для Docker):
#    DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/db
#    В Docker Compose используйте 'postgres', не 'localhost'!
#    Ошибка: "could not translate host name 'localhost'"
#
# Если используете Docker Compose, DATABASE_URL формируется автоматически из переменных выше.
# Если настраиваете вручную, убедитесь что все компоненты совпадают!
DATABASE_URL=postgresql+asyncpg://birthday_user:secure_password_2024@postgres:5432/birthday_calendar_db

# OpenRouter API Configuration
OPENROUTER_API_KEY=sk-or-v1-your-openrouter-api-key-here
OPENROUTER_REFERER=https://your-domain.com
OPENROUTER_MODEL=tng/deepseek-r1t2-chimera
OPENROUTER_BASE_URL=https://openrouter.ai/api/v1
OPENROUTER_TIMEOUT=30.0
OPENROUTER_MAX_RETRIES=3
OPENROUTER_TEMPERATURE=0.7
OPENROUTER_MAX_TOKENS=500

# Web Server Configuration
WEB_PORT=8000
API_HOST=0.0.0.0

# Frontend Configuration
# 
# ⚠️ КРИТИЧЕСКИ ВАЖНО для Telegram Mini App:
# VITE_API_URL ДОЛЖЕН быть внешним HTTPS URL, доступным из интернета!
# localhost НЕ РАБОТАЕТ для Mini App, так как Telegram не может обращаться к localhost.
#
# ============================================
# ВАРИАНТЫ НАСТРОЙКИ:
# ============================================
#
# 1. РАЗРАБОТКА (Development):
#    Используйте ngrok для создания туннеля:
#    - Установите ngrok: https://ngrok.com/download
#    - Запустите: ngrok http 8000
#    - Скопируйте HTTPS URL (например: https://abc123.ngrok.io)
#    - Установите: VITE_API_URL=https://abc123.ngrok.io
#
# 2. PRODUCTION с Nginx на нестандартных портах:
#    Пример: VITE_API_URL=https://your-domain.com:8001
#    (где 8001 - порт, на котором Nginx проксирует backend с SSL)
#
# 3. PRODUCTION с поддоменами:
#    Пример: VITE_API_URL=https://api.your-domain.com
#    (где api.your-domain.com - поддомен с SSL сертификатом)
#
# 4. PRODUCTION с Nginx на стандартных портах:
#    Пример: VITE_API_URL=https://your-domain.com
#    (если backend доступен на основном домене)
#
# ============================================
# ПРОВЕРКА:
# ============================================
# После настройки проверьте:
# 1. URL доступен из браузера (откройте в инкогнито)
# 2. URL использует HTTPS (не HTTP)
# 3. URL не содержит localhost или 127.0.0.1
# 4. CORS настроен правильно на backend
#
# Подробные инструкции: см. MINI_APP_SETUP.md
#
# ОБЯЗАТЕЛЬНО: Установите внешний HTTPS URL для API
# Проект работает на сервере, localhost не поддерживается
# Пример для production: VITE_API_URL=https://api.your-domain.com:8001
VITE_API_URL=https://your-domain.com:8001

# Application Settings
TIMEZONE=Asia/Tokyo
NOTIFICATION_HOUR=9
NOTIFICATION_MINUTE=0

# Development/Production
# 
# ВАЖНО: Значения по умолчанию настроены для PRODUCTION
# Для разработки измените эти значения на:
#   ENVIRONMENT=development
#   DEBUG=true
#
# В production CORS будет использовать только конкретные домены из ALLOWED_ORIGINS
# В development CORS разрешает все origins для удобства разработки
ENVIRONMENT=production
DEBUG=false

# CORS Configuration
# Разрешенные origins для CORS
# В development: '*' разрешает все origins (по умолчанию)
# В production: используйте конкретные домены через запятую, например:
#   ALLOWED_ORIGINS=https://web.telegram.org,https://telegram.org,https://your-domain.com
# Если не указано в production, используются только Telegram origins
ALLOWED_ORIGINS=*

# Telegram Mini App
# ВАЖНО: HTTPS обязателен, должен быть доступен из интернета!
# 
# Для разработки используйте ngrok для frontend: ngrok http 3000
# Пример: TELEGRAM_WEBAPP_URL=https://xyz789.ngrok.io
# 
# Для production с Nginx на нестандартных портах:
# Пример: TELEGRAM_WEBAPP_URL=https://your-domain.com:3001
# (где 3001 - порт, на котором Nginx проксирует frontend)
# 
# Для production с поддоменами:
# Пример: TELEGRAM_WEBAPP_URL=https://miniapp.your-domain.com
# 
# Если не настроен, кнопка Mini App не появится в боте.
# Подробные инструкции: см. MINI_APP_SETUP.md
TELEGRAM_WEBAPP_URL=https://your-domain.com

# Frontend Build Mode
# Режим сборки frontend: dev (по умолчанию) или production
# 
# DEVELOPMENT (FRONTEND_MODE=dev, FRONTEND_TARGET=runtime-dev):
#   - Используется Vite dev server
#   - Hot module replacement (HMR) доступен
#   - Больший размер образа (devDependencies включены)
#
# PRODUCTION (FRONTEND_MODE=production, FRONTEND_TARGET=runtime-prod):
#   - Используется production build с nginx
#   - Статические файлы обслуживаются через nginx
#   - Меньший размер образа, лучшая производительность
#   - Установите: FRONTEND_MODE=production и FRONTEND_TARGET=runtime-prod
#
# Для переключения в production mode:
#   1. Установите FRONTEND_MODE=production и FRONTEND_TARGET=runtime-prod в .env
#   2. Пересоберите образ: docker compose build frontend
#   3. Перезапустите контейнер: docker compose up -d frontend
FRONTEND_MODE=dev
FRONTEND_TARGET=runtime-dev

